=begin
#AKEYLESS Vault API

#RESTFull API for interacting with AKEYLESS Vault API

OpenAPI spec version: 0.1.1
Contact: refael@akeyless.io
Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.15

=end

require 'uri'

module SwaggerClient
  class DefaultApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create an association between role and auth method
    # Create an association between role and auth method Options:   role-name -    The role name to associate   am-name -    The auth method name to associate   sub-claims -    key/val of sub claims, ex. group=admins,developers   token -    Access token
    # @param role_name The role name to associate
    # @param am_name The auth method name to associate
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :sub_claims key/val of sub claims, ex. group&#x3D;admins,developers
    # @return [ReplyObj]
    def assoc_role_am(role_name, am_name, token, opts = {})
      data, _status_code, _headers = assoc_role_am_with_http_info(role_name, am_name, token, opts)
      data
    end

    # Create an association between role and auth method
    # Create an association between role and auth method Options:   role-name -    The role name to associate   am-name -    The auth method name to associate   sub-claims -    key/val of sub claims, ex. group&#x3D;admins,developers   token -    Access token
    # @param role_name The role name to associate
    # @param am_name The auth method name to associate
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :sub_claims key/val of sub claims, ex. group&#x3D;admins,developers
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def assoc_role_am_with_http_info(role_name, am_name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.assoc_role_am ...'
      end
      # verify the required parameter 'role_name' is set
      if @api_client.config.client_side_validation && role_name.nil?
        fail ArgumentError, "Missing the required parameter 'role_name' when calling DefaultApi.assoc_role_am"
      end
      # verify the required parameter 'am_name' is set
      if @api_client.config.client_side_validation && am_name.nil?
        fail ArgumentError, "Missing the required parameter 'am_name' when calling DefaultApi.assoc_role_am"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.assoc_role_am"
      end
      # resource path
      local_var_path = '/assoc-role-am'

      # query parameters
      query_params = {}
      query_params[:'role-name'] = role_name
      query_params[:'am-name'] = am_name
      query_params[:'token'] = token
      query_params[:'sub-claims'] = opts[:'sub_claims'] if !opts[:'sub_claims'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#assoc_role_am\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Authenticate to the service and returns a token to be used as a profile to execute the CLI without the need for re-authentication
    # Authenticate to the service and returns a token to be used as a profile to execute the CLI without the need for re-authentication Options:   access-id -    Access ID   access-type -    Access Type (access_key/password/saml/ldap/azure_ad/aws_iam/universal_identity)   access-key -    Access key (relevant only for access-type=access_key)   cloud-id -    The cloued identity (relevant only for access-type=azure_ad,awd_im)   uid_token -    The universal_identity token (relevant only for access-type=universal_identity)   admin-password -    Password (relevant only for access-type=password)   admin-email -    Email (relevant only for access-type=password)   ldap_proxy_url -    Address URL for LDAP proxy (relevant only for access-type=ldap)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_id Access ID
    # @option opts [String] :access_type Access Type (access_key/password/saml/ldap/azure_ad/aws_iam/universal_identity)
    # @option opts [String] :access_key Access key (relevant only for access-type&#x3D;access_key)
    # @option opts [String] :cloud_id The cloued identity (relevant only for access-type&#x3D;azure_ad,awd_im)
    # @option opts [String] :uid_token The universal_identity token (relevant only for access-type&#x3D;universal_identity)
    # @option opts [String] :admin_password Password (relevant only for access-type&#x3D;password)
    # @option opts [String] :admin_email Email (relevant only for access-type&#x3D;password)
    # @option opts [String] :ldap_proxy_url Address URL for LDAP proxy (relevant only for access-type&#x3D;ldap)
    # @return [ReplyObj]
    def auth(opts = {})
      data, _status_code, _headers = auth_with_http_info(opts)
      data
    end

    # Authenticate to the service and returns a token to be used as a profile to execute the CLI without the need for re-authentication
    # Authenticate to the service and returns a token to be used as a profile to execute the CLI without the need for re-authentication Options:   access-id -    Access ID   access-type -    Access Type (access_key/password/saml/ldap/azure_ad/aws_iam/universal_identity)   access-key -    Access key (relevant only for access-type&#x3D;access_key)   cloud-id -    The cloued identity (relevant only for access-type&#x3D;azure_ad,awd_im)   uid_token -    The universal_identity token (relevant only for access-type&#x3D;universal_identity)   admin-password -    Password (relevant only for access-type&#x3D;password)   admin-email -    Email (relevant only for access-type&#x3D;password)   ldap_proxy_url -    Address URL for LDAP proxy (relevant only for access-type&#x3D;ldap)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_id Access ID
    # @option opts [String] :access_type Access Type (access_key/password/saml/ldap/azure_ad/aws_iam/universal_identity)
    # @option opts [String] :access_key Access key (relevant only for access-type&#x3D;access_key)
    # @option opts [String] :cloud_id The cloued identity (relevant only for access-type&#x3D;azure_ad,awd_im)
    # @option opts [String] :uid_token The universal_identity token (relevant only for access-type&#x3D;universal_identity)
    # @option opts [String] :admin_password Password (relevant only for access-type&#x3D;password)
    # @option opts [String] :admin_email Email (relevant only for access-type&#x3D;password)
    # @option opts [String] :ldap_proxy_url Address URL for LDAP proxy (relevant only for access-type&#x3D;ldap)
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def auth_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.auth ...'
      end
      # resource path
      local_var_path = '/auth'

      # query parameters
      query_params = {}
      query_params[:'access-id'] = opts[:'access_id'] if !opts[:'access_id'].nil?
      query_params[:'access-type'] = opts[:'access_type'] if !opts[:'access_type'].nil?
      query_params[:'access-key'] = opts[:'access_key'] if !opts[:'access_key'].nil?
      query_params[:'cloud-id'] = opts[:'cloud_id'] if !opts[:'cloud_id'].nil?
      query_params[:'uid_token'] = opts[:'uid_token'] if !opts[:'uid_token'].nil?
      query_params[:'admin-password'] = opts[:'admin_password'] if !opts[:'admin_password'].nil?
      query_params[:'admin-email'] = opts[:'admin_email'] if !opts[:'admin_email'].nil?
      query_params[:'ldap_proxy_url'] = opts[:'ldap_proxy_url'] if !opts[:'ldap_proxy_url'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#auth\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Configure client profile.
    # Configure client profile. Options:   access-id -    Access ID   access-key -    Access Key   access-type -    Access Type (access_key/password/azure_ad/saml/ldap/aws_iam/universal_identity)   admin-password -    Password (relevant only for access-type=password)   admin-email -    Email (relevant only for access-type=password)   uid_token -    The universal_identity token (relevant only for access-type=universal_identity)   ldap_proxy_url -    Address URL for ldap proxy (relevant only for access-type=ldap)   azure_ad_object_id -    Azure Active Directory ObjectId (relevant only for access-type=azure_ad)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_id Access ID
    # @option opts [String] :access_key Access Key
    # @option opts [String] :access_type Access Type (access_key/password/azure_ad/saml/ldap/aws_iam/universal_identity)
    # @option opts [String] :admin_password Password (relevant only for access-type&#x3D;password)
    # @option opts [String] :admin_email Email (relevant only for access-type&#x3D;password)
    # @option opts [String] :uid_token The universal_identity token (relevant only for access-type&#x3D;universal_identity)
    # @option opts [String] :ldap_proxy_url Address URL for ldap proxy (relevant only for access-type&#x3D;ldap)
    # @option opts [String] :azure_ad_object_id Azure Active Directory ObjectId (relevant only for access-type&#x3D;azure_ad)
    # @return [ReplyObj]
    def configure(opts = {})
      data, _status_code, _headers = configure_with_http_info(opts)
      data
    end

    # Configure client profile.
    # Configure client profile. Options:   access-id -    Access ID   access-key -    Access Key   access-type -    Access Type (access_key/password/azure_ad/saml/ldap/aws_iam/universal_identity)   admin-password -    Password (relevant only for access-type&#x3D;password)   admin-email -    Email (relevant only for access-type&#x3D;password)   uid_token -    The universal_identity token (relevant only for access-type&#x3D;universal_identity)   ldap_proxy_url -    Address URL for ldap proxy (relevant only for access-type&#x3D;ldap)   azure_ad_object_id -    Azure Active Directory ObjectId (relevant only for access-type&#x3D;azure_ad)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_id Access ID
    # @option opts [String] :access_key Access Key
    # @option opts [String] :access_type Access Type (access_key/password/azure_ad/saml/ldap/aws_iam/universal_identity)
    # @option opts [String] :admin_password Password (relevant only for access-type&#x3D;password)
    # @option opts [String] :admin_email Email (relevant only for access-type&#x3D;password)
    # @option opts [String] :uid_token The universal_identity token (relevant only for access-type&#x3D;universal_identity)
    # @option opts [String] :ldap_proxy_url Address URL for ldap proxy (relevant only for access-type&#x3D;ldap)
    # @option opts [String] :azure_ad_object_id Azure Active Directory ObjectId (relevant only for access-type&#x3D;azure_ad)
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def configure_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.configure ...'
      end
      # resource path
      local_var_path = '/configure'

      # query parameters
      query_params = {}
      query_params[:'access-id'] = opts[:'access_id'] if !opts[:'access_id'].nil?
      query_params[:'access-key'] = opts[:'access_key'] if !opts[:'access_key'].nil?
      query_params[:'access-type'] = opts[:'access_type'] if !opts[:'access_type'].nil?
      query_params[:'admin-password'] = opts[:'admin_password'] if !opts[:'admin_password'].nil?
      query_params[:'admin-email'] = opts[:'admin_email'] if !opts[:'admin_email'].nil?
      query_params[:'uid_token'] = opts[:'uid_token'] if !opts[:'uid_token'].nil?
      query_params[:'ldap_proxy_url'] = opts[:'ldap_proxy_url'] if !opts[:'ldap_proxy_url'].nil?
      query_params[:'azure_ad_object_id'] = opts[:'azure_ad_object_id'] if !opts[:'azure_ad_object_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#configure\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Auth Method in the account
    # Create a new Auth Method in the account Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist with the IPs that the access is restricted to   token -    Access token
    # @param name Auth Method name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist with the IPs that the access is restricted to
    # @return [ReplyObj]
    def create_auth_method(name, token, opts = {})
      data, _status_code, _headers = create_auth_method_with_http_info(name, token, opts)
      data
    end

    # Create a new Auth Method in the account
    # Create a new Auth Method in the account Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist with the IPs that the access is restricted to   token -    Access token
    # @param name Auth Method name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist with the IPs that the access is restricted to
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_auth_method_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_auth_method ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_auth_method"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_auth_method"
      end
      # resource path
      local_var_path = '/create-auth-method'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token
      query_params[:'access-expires'] = opts[:'access_expires'] if !opts[:'access_expires'].nil?
      query_params[:'bound-ips'] = opts[:'bound_ips'] if !opts[:'bound_ips'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_auth_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Auth Method that will be able to authenticate using AWS IAM credentials
    # Create a new Auth Method that will be able to authenticate using AWS IAM credentials Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   sts-url -    sts URL   bound-AWS-account-id -    A list of AWS account-IDs that the access is restricted to   bound-arn -    A list of full arns that the access is restricted to   bound-role-name -    A list of full role-name that the access is restricted to   bound-role-id -    A list of full role ids that the access is restricted to   bound-resource-id -    A list of full resource ids that the access is restricted to   bound-user-name -    A list of full user-name that the access is restricted to   bound-user-id -    A list of full user ids that the access is restricted to   token -    Access token
    # @param name Auth Method name
    # @param bound_aws_account_id A list of AWS account-IDs that the access is restricted to
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @option opts [String] :sts_url sts URL
    # @option opts [String] :bound_arn A list of full arns that the access is restricted to
    # @option opts [String] :bound_role_name A list of full role-name that the access is restricted to
    # @option opts [String] :bound_role_id A list of full role ids that the access is restricted to
    # @option opts [String] :bound_resource_id A list of full resource ids that the access is restricted to
    # @option opts [String] :bound_user_name A list of full user-name that the access is restricted to
    # @option opts [String] :bound_user_id A list of full user ids that the access is restricted to
    # @return [ReplyObj]
    def create_auth_method_aws_iam(name, bound_aws_account_id, token, opts = {})
      data, _status_code, _headers = create_auth_method_aws_iam_with_http_info(name, bound_aws_account_id, token, opts)
      data
    end

    # Create a new Auth Method that will be able to authenticate using AWS IAM credentials
    # Create a new Auth Method that will be able to authenticate using AWS IAM credentials Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   sts-url -    sts URL   bound-AWS-account-id -    A list of AWS account-IDs that the access is restricted to   bound-arn -    A list of full arns that the access is restricted to   bound-role-name -    A list of full role-name that the access is restricted to   bound-role-id -    A list of full role ids that the access is restricted to   bound-resource-id -    A list of full resource ids that the access is restricted to   bound-user-name -    A list of full user-name that the access is restricted to   bound-user-id -    A list of full user ids that the access is restricted to   token -    Access token
    # @param name Auth Method name
    # @param bound_aws_account_id A list of AWS account-IDs that the access is restricted to
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @option opts [String] :sts_url sts URL
    # @option opts [String] :bound_arn A list of full arns that the access is restricted to
    # @option opts [String] :bound_role_name A list of full role-name that the access is restricted to
    # @option opts [String] :bound_role_id A list of full role ids that the access is restricted to
    # @option opts [String] :bound_resource_id A list of full resource ids that the access is restricted to
    # @option opts [String] :bound_user_name A list of full user-name that the access is restricted to
    # @option opts [String] :bound_user_id A list of full user ids that the access is restricted to
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_auth_method_aws_iam_with_http_info(name, bound_aws_account_id, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_auth_method_aws_iam ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_auth_method_aws_iam"
      end
      # verify the required parameter 'bound_aws_account_id' is set
      if @api_client.config.client_side_validation && bound_aws_account_id.nil?
        fail ArgumentError, "Missing the required parameter 'bound_aws_account_id' when calling DefaultApi.create_auth_method_aws_iam"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_auth_method_aws_iam"
      end
      # resource path
      local_var_path = '/create-auth-method-aws-iam'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'bound-AWS-account-id'] = bound_aws_account_id
      query_params[:'token'] = token
      query_params[:'access-expires'] = opts[:'access_expires'] if !opts[:'access_expires'].nil?
      query_params[:'bound-ips'] = opts[:'bound_ips'] if !opts[:'bound_ips'].nil?
      query_params[:'sts-url'] = opts[:'sts_url'] if !opts[:'sts_url'].nil?
      query_params[:'bound-arn'] = opts[:'bound_arn'] if !opts[:'bound_arn'].nil?
      query_params[:'bound-role-name'] = opts[:'bound_role_name'] if !opts[:'bound_role_name'].nil?
      query_params[:'bound-role-id'] = opts[:'bound_role_id'] if !opts[:'bound_role_id'].nil?
      query_params[:'bound-resource-id'] = opts[:'bound_resource_id'] if !opts[:'bound_resource_id'].nil?
      query_params[:'bound-user-name'] = opts[:'bound_user_name'] if !opts[:'bound_user_name'].nil?
      query_params[:'bound-user-id'] = opts[:'bound_user_id'] if !opts[:'bound_user_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_auth_method_aws_iam\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Auth Method that will be able to authenticate using Azure Active Directory credentials
    # Create a new Auth Method that will be able to authenticate using Azure Active Directory credentials Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   bound-tenant-id -    The Azure tenant id that the access is restricted to   issuer -    Issuer URL   jwks-uri -    The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.   audience -    The audience in the JWT   bound-spid -    A list of service principal IDs that the access is restricted to   bound-group-id -    A list of group ids that the access is restricted to   bound-sub-id -    A list of subscription ids that the access is restricted to   bound-rg-id -    A list of resource groups that the access is restricted to   bound-providers -    A list of resource providers that the access is restricted to (e.g, Microsoft.Compute, Microsoft.ManagedIdentity, etc)   bound-resource-types -    A list of resource types that the access is restricted to (e.g, virtualMachines, userAssignedIdentities, etc)   bound-resource-names -    A list of resource names that the access is restricted to (e.g, a virtual machine name, scale set name, etc).   bound-resource-id -    A list of full resource ids that the access is restricted to   token -    Access token
    # @param name Auth Method name
    # @param bound_tenant_id The Azure tenant id that the access is restricted to
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @option opts [String] :issuer Issuer URL
    # @option opts [String] :jwks_uri The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.
    # @option opts [String] :audience The audience in the JWT
    # @option opts [String] :bound_spid A list of service principal IDs that the access is restricted to
    # @option opts [String] :bound_group_id A list of group ids that the access is restricted to
    # @option opts [String] :bound_sub_id A list of subscription ids that the access is restricted to
    # @option opts [String] :bound_rg_id A list of resource groups that the access is restricted to
    # @option opts [String] :bound_providers A list of resource providers that the access is restricted to (e.g, Microsoft.Compute, Microsoft.ManagedIdentity, etc)
    # @option opts [String] :bound_resource_types A list of resource types that the access is restricted to (e.g, virtualMachines, userAssignedIdentities, etc)
    # @option opts [String] :bound_resource_names A list of resource names that the access is restricted to (e.g, a virtual machine name, scale set name, etc).
    # @option opts [String] :bound_resource_id A list of full resource ids that the access is restricted to
    # @return [ReplyObj]
    def create_auth_method_azure_ad(name, bound_tenant_id, token, opts = {})
      data, _status_code, _headers = create_auth_method_azure_ad_with_http_info(name, bound_tenant_id, token, opts)
      data
    end

    # Create a new Auth Method that will be able to authenticate using Azure Active Directory credentials
    # Create a new Auth Method that will be able to authenticate using Azure Active Directory credentials Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   bound-tenant-id -    The Azure tenant id that the access is restricted to   issuer -    Issuer URL   jwks-uri -    The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.   audience -    The audience in the JWT   bound-spid -    A list of service principal IDs that the access is restricted to   bound-group-id -    A list of group ids that the access is restricted to   bound-sub-id -    A list of subscription ids that the access is restricted to   bound-rg-id -    A list of resource groups that the access is restricted to   bound-providers -    A list of resource providers that the access is restricted to (e.g, Microsoft.Compute, Microsoft.ManagedIdentity, etc)   bound-resource-types -    A list of resource types that the access is restricted to (e.g, virtualMachines, userAssignedIdentities, etc)   bound-resource-names -    A list of resource names that the access is restricted to (e.g, a virtual machine name, scale set name, etc).   bound-resource-id -    A list of full resource ids that the access is restricted to   token -    Access token
    # @param name Auth Method name
    # @param bound_tenant_id The Azure tenant id that the access is restricted to
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @option opts [String] :issuer Issuer URL
    # @option opts [String] :jwks_uri The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.
    # @option opts [String] :audience The audience in the JWT
    # @option opts [String] :bound_spid A list of service principal IDs that the access is restricted to
    # @option opts [String] :bound_group_id A list of group ids that the access is restricted to
    # @option opts [String] :bound_sub_id A list of subscription ids that the access is restricted to
    # @option opts [String] :bound_rg_id A list of resource groups that the access is restricted to
    # @option opts [String] :bound_providers A list of resource providers that the access is restricted to (e.g, Microsoft.Compute, Microsoft.ManagedIdentity, etc)
    # @option opts [String] :bound_resource_types A list of resource types that the access is restricted to (e.g, virtualMachines, userAssignedIdentities, etc)
    # @option opts [String] :bound_resource_names A list of resource names that the access is restricted to (e.g, a virtual machine name, scale set name, etc).
    # @option opts [String] :bound_resource_id A list of full resource ids that the access is restricted to
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_auth_method_azure_ad_with_http_info(name, bound_tenant_id, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_auth_method_azure_ad ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_auth_method_azure_ad"
      end
      # verify the required parameter 'bound_tenant_id' is set
      if @api_client.config.client_side_validation && bound_tenant_id.nil?
        fail ArgumentError, "Missing the required parameter 'bound_tenant_id' when calling DefaultApi.create_auth_method_azure_ad"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_auth_method_azure_ad"
      end
      # resource path
      local_var_path = '/create-auth-method-azure-ad'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'bound-tenant-id'] = bound_tenant_id
      query_params[:'token'] = token
      query_params[:'access-expires'] = opts[:'access_expires'] if !opts[:'access_expires'].nil?
      query_params[:'bound-ips'] = opts[:'bound_ips'] if !opts[:'bound_ips'].nil?
      query_params[:'issuer'] = opts[:'issuer'] if !opts[:'issuer'].nil?
      query_params[:'jwks-uri'] = opts[:'jwks_uri'] if !opts[:'jwks_uri'].nil?
      query_params[:'audience'] = opts[:'audience'] if !opts[:'audience'].nil?
      query_params[:'bound-spid'] = opts[:'bound_spid'] if !opts[:'bound_spid'].nil?
      query_params[:'bound-group-id'] = opts[:'bound_group_id'] if !opts[:'bound_group_id'].nil?
      query_params[:'bound-sub-id'] = opts[:'bound_sub_id'] if !opts[:'bound_sub_id'].nil?
      query_params[:'bound-rg-id'] = opts[:'bound_rg_id'] if !opts[:'bound_rg_id'].nil?
      query_params[:'bound-providers'] = opts[:'bound_providers'] if !opts[:'bound_providers'].nil?
      query_params[:'bound-resource-types'] = opts[:'bound_resource_types'] if !opts[:'bound_resource_types'].nil?
      query_params[:'bound-resource-names'] = opts[:'bound_resource_names'] if !opts[:'bound_resource_names'].nil?
      query_params[:'bound-resource-id'] = opts[:'bound_resource_id'] if !opts[:'bound_resource_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_auth_method_azure_ad\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Auth Method that will be able to authenticate using LDAP
    # Create a new Auth Method that will be able to authenticate using LDAP Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   public-key-file-path -    A public key generated for LDAP authentication method on Akeyless [RSA2048]   token -    Access token
    # @param name Auth Method name
    # @param public_key_file_path A public key generated for LDAP authentication method on Akeyless [RSA2048]
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @return [ReplyObj]
    def create_auth_method_ldap(name, public_key_file_path, token, opts = {})
      data, _status_code, _headers = create_auth_method_ldap_with_http_info(name, public_key_file_path, token, opts)
      data
    end

    # Create a new Auth Method that will be able to authenticate using LDAP
    # Create a new Auth Method that will be able to authenticate using LDAP Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   public-key-file-path -    A public key generated for LDAP authentication method on Akeyless [RSA2048]   token -    Access token
    # @param name Auth Method name
    # @param public_key_file_path A public key generated for LDAP authentication method on Akeyless [RSA2048]
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_auth_method_ldap_with_http_info(name, public_key_file_path, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_auth_method_ldap ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_auth_method_ldap"
      end
      # verify the required parameter 'public_key_file_path' is set
      if @api_client.config.client_side_validation && public_key_file_path.nil?
        fail ArgumentError, "Missing the required parameter 'public_key_file_path' when calling DefaultApi.create_auth_method_ldap"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_auth_method_ldap"
      end
      # resource path
      local_var_path = '/create-auth-method-ldap'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'public-key-file-path'] = public_key_file_path
      query_params[:'token'] = token
      query_params[:'access-expires'] = opts[:'access_expires'] if !opts[:'access_expires'].nil?
      query_params[:'bound-ips'] = opts[:'bound_ips'] if !opts[:'bound_ips'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_auth_method_ldap\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Auth Method that will be able to authenticate using OpenId/OAuth2
    # Create a new Auth Method that will be able to authenticate using OpenId/OAuth2 Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   bound-clients-ids -    The clients ids that the access is restricted to   issuer -    Issuer URL   jwks-uri -    The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.   audience -    The audience in the JWT   token -    Access token
    # @param name Auth Method name
    # @param bound_clients_ids The clients ids that the access is restricted to
    # @param issuer Issuer URL
    # @param jwks_uri The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.
    # @param audience The audience in the JWT
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @return [ReplyObj]
    def create_auth_method_oauth2(name, bound_clients_ids, issuer, jwks_uri, audience, token, opts = {})
      data, _status_code, _headers = create_auth_method_oauth2_with_http_info(name, bound_clients_ids, issuer, jwks_uri, audience, token, opts)
      data
    end

    # Create a new Auth Method that will be able to authenticate using OpenId/OAuth2
    # Create a new Auth Method that will be able to authenticate using OpenId/OAuth2 Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   bound-clients-ids -    The clients ids that the access is restricted to   issuer -    Issuer URL   jwks-uri -    The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.   audience -    The audience in the JWT   token -    Access token
    # @param name Auth Method name
    # @param bound_clients_ids The clients ids that the access is restricted to
    # @param issuer Issuer URL
    # @param jwks_uri The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.
    # @param audience The audience in the JWT
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_auth_method_oauth2_with_http_info(name, bound_clients_ids, issuer, jwks_uri, audience, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_auth_method_oauth2 ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_auth_method_oauth2"
      end
      # verify the required parameter 'bound_clients_ids' is set
      if @api_client.config.client_side_validation && bound_clients_ids.nil?
        fail ArgumentError, "Missing the required parameter 'bound_clients_ids' when calling DefaultApi.create_auth_method_oauth2"
      end
      # verify the required parameter 'issuer' is set
      if @api_client.config.client_side_validation && issuer.nil?
        fail ArgumentError, "Missing the required parameter 'issuer' when calling DefaultApi.create_auth_method_oauth2"
      end
      # verify the required parameter 'jwks_uri' is set
      if @api_client.config.client_side_validation && jwks_uri.nil?
        fail ArgumentError, "Missing the required parameter 'jwks_uri' when calling DefaultApi.create_auth_method_oauth2"
      end
      # verify the required parameter 'audience' is set
      if @api_client.config.client_side_validation && audience.nil?
        fail ArgumentError, "Missing the required parameter 'audience' when calling DefaultApi.create_auth_method_oauth2"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_auth_method_oauth2"
      end
      # resource path
      local_var_path = '/create-auth-method-oauth2'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'bound-clients-ids'] = bound_clients_ids
      query_params[:'issuer'] = issuer
      query_params[:'jwks-uri'] = jwks_uri
      query_params[:'audience'] = audience
      query_params[:'token'] = token
      query_params[:'access-expires'] = opts[:'access_expires'] if !opts[:'access_expires'].nil?
      query_params[:'bound-ips'] = opts[:'bound_ips'] if !opts[:'bound_ips'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_auth_method_oauth2\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Create a new Auth Method that will be able to authenticate using SAML
    # Create a new Auth Method that will be able to authenticate using SAML Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   idp-metadata-url -    IDP metadata url   idp-metadata-xml -    IDP metadata xml   token -    Access token
    # @param name Auth Method name
    # @param idp_metadata_url IDP metadata url
    # @param idp_metadata_xml IDP metadata xml
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @return [ReplyObj]
    def create_auth_method_saml(name, idp_metadata_url, idp_metadata_xml, token, opts = {})
      data, _status_code, _headers = create_auth_method_saml_with_http_info(name, idp_metadata_url, idp_metadata_xml, token, opts)
      data
    end

    # Create a new Auth Method that will be able to authenticate using SAML
    # Create a new Auth Method that will be able to authenticate using SAML Options:   name -    Auth Method name   access-expires -    Access expiration date in Unix timestamp (select 0 for access without expiry date)   bound-ips -    A CIDR whitelist of the IPs that the access is restricted to   idp-metadata-url -    IDP metadata url   idp-metadata-xml -    IDP metadata xml   token -    Access token
    # @param name Auth Method name
    # @param idp_metadata_url IDP metadata url
    # @param idp_metadata_xml IDP metadata xml
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :access_expires Access expiration date in Unix timestamp (select 0 for access without expiry date)
    # @option opts [String] :bound_ips A CIDR whitelist of the IPs that the access is restricted to
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_auth_method_saml_with_http_info(name, idp_metadata_url, idp_metadata_xml, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_auth_method_saml ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_auth_method_saml"
      end
      # verify the required parameter 'idp_metadata_url' is set
      if @api_client.config.client_side_validation && idp_metadata_url.nil?
        fail ArgumentError, "Missing the required parameter 'idp_metadata_url' when calling DefaultApi.create_auth_method_saml"
      end
      # verify the required parameter 'idp_metadata_xml' is set
      if @api_client.config.client_side_validation && idp_metadata_xml.nil?
        fail ArgumentError, "Missing the required parameter 'idp_metadata_xml' when calling DefaultApi.create_auth_method_saml"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_auth_method_saml"
      end
      # resource path
      local_var_path = '/create-auth-method-saml'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'idp-metadata-url'] = idp_metadata_url
      query_params[:'idp-metadata-xml'] = idp_metadata_xml
      query_params[:'token'] = token
      query_params[:'access-expires'] = opts[:'access_expires'] if !opts[:'access_expires'].nil?
      query_params[:'bound-ips'] = opts[:'bound_ips'] if !opts[:'bound_ips'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_auth_method_saml\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new dynamic secret item
    # Creates a new dynamic secret item Options:   name -    Dynamic secret name   metadata -    Metadata about the dynamic secret   tag -    List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   key -    The name of a key that used to encrypt the dynamic secret values (if empty, the account default protectionKey key will be used)   token -    Access token
    # @param name Dynamic secret name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata Metadata about the dynamic secret
    # @option opts [String] :tag List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :key The name of a key that used to encrypt the dynamic secret values (if empty, the account default protectionKey key will be used)
    # @return [ReplyObj]
    def create_dynamic_secret(name, token, opts = {})
      data, _status_code, _headers = create_dynamic_secret_with_http_info(name, token, opts)
      data
    end

    # Creates a new dynamic secret item
    # Creates a new dynamic secret item Options:   name -    Dynamic secret name   metadata -    Metadata about the dynamic secret   tag -    List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   key -    The name of a key that used to encrypt the dynamic secret values (if empty, the account default protectionKey key will be used)   token -    Access token
    # @param name Dynamic secret name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata Metadata about the dynamic secret
    # @option opts [String] :tag List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :key The name of a key that used to encrypt the dynamic secret values (if empty, the account default protectionKey key will be used)
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_dynamic_secret_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_dynamic_secret ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_dynamic_secret"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_dynamic_secret"
      end
      # resource path
      local_var_path = '/create-dynamic-secret'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token
      query_params[:'metadata'] = opts[:'metadata'] if !opts[:'metadata'].nil?
      query_params[:'tag'] = opts[:'tag'] if !opts[:'tag'].nil?
      query_params[:'key'] = opts[:'key'] if !opts[:'key'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_dynamic_secret\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new key
    # Creates a new key Options:   name -    Key name   alg -    Key type. options- [AES128GCM, AES256GCM, AES128SIV, AES256SIV, RSA1024, RSA2048]   metadata -    Metadata about the key   tag -    List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   split-level -    The number of fragments that the item will be split into (not includes customer fragment)   customer-frg-id -    The customer fragment ID that will be used to create the key (if empty, the key will be created independently of a customer fragment)   token -    Access token
    # @param name Key name
    # @param alg Key type. options- [AES128GCM, AES256GCM, AES128SIV, AES256SIV, RSA1024, RSA2048]
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata Metadata about the key
    # @option opts [String] :tag List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :split_level The number of fragments that the item will be split into (not includes customer fragment)
    # @option opts [String] :customer_frg_id The customer fragment ID that will be used to create the key (if empty, the key will be created independently of a customer fragment)
    # @return [ReplyObj]
    def create_key(name, alg, token, opts = {})
      data, _status_code, _headers = create_key_with_http_info(name, alg, token, opts)
      data
    end

    # Creates a new key
    # Creates a new key Options:   name -    Key name   alg -    Key type. options- [AES128GCM, AES256GCM, AES128SIV, AES256SIV, RSA1024, RSA2048]   metadata -    Metadata about the key   tag -    List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   split-level -    The number of fragments that the item will be split into (not includes customer fragment)   customer-frg-id -    The customer fragment ID that will be used to create the key (if empty, the key will be created independently of a customer fragment)   token -    Access token
    # @param name Key name
    # @param alg Key type. options- [AES128GCM, AES256GCM, AES128SIV, AES256SIV, RSA1024, RSA2048]
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata Metadata about the key
    # @option opts [String] :tag List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :split_level The number of fragments that the item will be split into (not includes customer fragment)
    # @option opts [String] :customer_frg_id The customer fragment ID that will be used to create the key (if empty, the key will be created independently of a customer fragment)
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_key_with_http_info(name, alg, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_key ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_key"
      end
      # verify the required parameter 'alg' is set
      if @api_client.config.client_side_validation && alg.nil?
        fail ArgumentError, "Missing the required parameter 'alg' when calling DefaultApi.create_key"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_key"
      end
      # resource path
      local_var_path = '/create-key'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'alg'] = alg
      query_params[:'token'] = token
      query_params[:'metadata'] = opts[:'metadata'] if !opts[:'metadata'].nil?
      query_params[:'tag'] = opts[:'tag'] if !opts[:'tag'].nil?
      query_params[:'split-level'] = opts[:'split_level'] if !opts[:'split_level'].nil?
      query_params[:'customer-frg-id'] = opts[:'customer_frg_id'] if !opts[:'customer_frg_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new PKI certificate issuer
    # Creates a new PKI certificate issuer Options:   name -    PKI certificate issuer name   signer-key-name -    A key to sign the certificate with   allowed-domains -    A list of the allowed domains that clients can request to be included in the certificate (in a comma-delimited list)   allowed-uri-sans -    A list of the allowed URIs that clients can request to be included in the certificate as part of the URI Subject Alternative Names (in a comma-delimited list)   allow-subdomains -    If set, clients can request certificates for subdomains and wildcard subdomains of the allowed domains   not-enforce-hostnames -    If set, any names are allowed for CN and SANs in the certificate and not only a valid host name   allow-any-name -    If set, clients can request certificates for any CN   not-require-cn -    If set, clients can request certificates without a CN   server-flag -    If set, certificates will be flagged for server auth use   client-flag -    If set, certificates will be flagged for client auth use   code-signing-flag -    If set, certificates will be flagged for code signing use   key-usage -    A comma-separated string or list of key usages   organization-units -    A comma-separated list of organizational units (OU) that will be set in the issued certificate   organizations -    A comma-separated list of organizations (O) that will be set in the issued certificate   country -    A comma-separated list of the country that will be set in the issued certificate   locality -    A comma-separated list of the locality that will be set in the issued certificate   province -    A comma-separated list of the province that will be set in the issued certificate   street-address -    A comma-separated list of the street address that will be set in the issued certificate   postal-code -    A comma-separated list of the postal code that will be set in the issued certificate   ttl -    The requested Time To Live for the certificate, use second units   metadata -    A metadata about the issuer   token -    Access token
    # @param name PKI certificate issuer name
    # @param signer_key_name A key to sign the certificate with
    # @param ttl The requested Time To Live for the certificate, use second units
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :allowed_domains A list of the allowed domains that clients can request to be included in the certificate (in a comma-delimited list)
    # @option opts [String] :allowed_uri_sans A list of the allowed URIs that clients can request to be included in the certificate as part of the URI Subject Alternative Names (in a comma-delimited list)
    # @option opts [String] :allow_subdomains If set, clients can request certificates for subdomains and wildcard subdomains of the allowed domains
    # @option opts [String] :not_enforce_hostnames If set, any names are allowed for CN and SANs in the certificate and not only a valid host name
    # @option opts [String] :allow_any_name If set, clients can request certificates for any CN
    # @option opts [String] :not_require_cn If set, clients can request certificates without a CN
    # @option opts [String] :server_flag If set, certificates will be flagged for server auth use
    # @option opts [String] :client_flag If set, certificates will be flagged for client auth use
    # @option opts [String] :code_signing_flag If set, certificates will be flagged for code signing use
    # @option opts [String] :key_usage A comma-separated string or list of key usages
    # @option opts [String] :organization_units A comma-separated list of organizational units (OU) that will be set in the issued certificate
    # @option opts [String] :organizations A comma-separated list of organizations (O) that will be set in the issued certificate
    # @option opts [String] :country A comma-separated list of the country that will be set in the issued certificate
    # @option opts [String] :locality A comma-separated list of the locality that will be set in the issued certificate
    # @option opts [String] :province A comma-separated list of the province that will be set in the issued certificate
    # @option opts [String] :street_address A comma-separated list of the street address that will be set in the issued certificate
    # @option opts [String] :postal_code A comma-separated list of the postal code that will be set in the issued certificate
    # @option opts [String] :metadata A metadata about the issuer
    # @return [ReplyObj]
    def create_pki_cert_issuer(name, signer_key_name, ttl, token, opts = {})
      data, _status_code, _headers = create_pki_cert_issuer_with_http_info(name, signer_key_name, ttl, token, opts)
      data
    end

    # Creates a new PKI certificate issuer
    # Creates a new PKI certificate issuer Options:   name -    PKI certificate issuer name   signer-key-name -    A key to sign the certificate with   allowed-domains -    A list of the allowed domains that clients can request to be included in the certificate (in a comma-delimited list)   allowed-uri-sans -    A list of the allowed URIs that clients can request to be included in the certificate as part of the URI Subject Alternative Names (in a comma-delimited list)   allow-subdomains -    If set, clients can request certificates for subdomains and wildcard subdomains of the allowed domains   not-enforce-hostnames -    If set, any names are allowed for CN and SANs in the certificate and not only a valid host name   allow-any-name -    If set, clients can request certificates for any CN   not-require-cn -    If set, clients can request certificates without a CN   server-flag -    If set, certificates will be flagged for server auth use   client-flag -    If set, certificates will be flagged for client auth use   code-signing-flag -    If set, certificates will be flagged for code signing use   key-usage -    A comma-separated string or list of key usages   organization-units -    A comma-separated list of organizational units (OU) that will be set in the issued certificate   organizations -    A comma-separated list of organizations (O) that will be set in the issued certificate   country -    A comma-separated list of the country that will be set in the issued certificate   locality -    A comma-separated list of the locality that will be set in the issued certificate   province -    A comma-separated list of the province that will be set in the issued certificate   street-address -    A comma-separated list of the street address that will be set in the issued certificate   postal-code -    A comma-separated list of the postal code that will be set in the issued certificate   ttl -    The requested Time To Live for the certificate, use second units   metadata -    A metadata about the issuer   token -    Access token
    # @param name PKI certificate issuer name
    # @param signer_key_name A key to sign the certificate with
    # @param ttl The requested Time To Live for the certificate, use second units
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :allowed_domains A list of the allowed domains that clients can request to be included in the certificate (in a comma-delimited list)
    # @option opts [String] :allowed_uri_sans A list of the allowed URIs that clients can request to be included in the certificate as part of the URI Subject Alternative Names (in a comma-delimited list)
    # @option opts [String] :allow_subdomains If set, clients can request certificates for subdomains and wildcard subdomains of the allowed domains
    # @option opts [String] :not_enforce_hostnames If set, any names are allowed for CN and SANs in the certificate and not only a valid host name
    # @option opts [String] :allow_any_name If set, clients can request certificates for any CN
    # @option opts [String] :not_require_cn If set, clients can request certificates without a CN
    # @option opts [String] :server_flag If set, certificates will be flagged for server auth use
    # @option opts [String] :client_flag If set, certificates will be flagged for client auth use
    # @option opts [String] :code_signing_flag If set, certificates will be flagged for code signing use
    # @option opts [String] :key_usage A comma-separated string or list of key usages
    # @option opts [String] :organization_units A comma-separated list of organizational units (OU) that will be set in the issued certificate
    # @option opts [String] :organizations A comma-separated list of organizations (O) that will be set in the issued certificate
    # @option opts [String] :country A comma-separated list of the country that will be set in the issued certificate
    # @option opts [String] :locality A comma-separated list of the locality that will be set in the issued certificate
    # @option opts [String] :province A comma-separated list of the province that will be set in the issued certificate
    # @option opts [String] :street_address A comma-separated list of the street address that will be set in the issued certificate
    # @option opts [String] :postal_code A comma-separated list of the postal code that will be set in the issued certificate
    # @option opts [String] :metadata A metadata about the issuer
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_pki_cert_issuer_with_http_info(name, signer_key_name, ttl, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_pki_cert_issuer ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_pki_cert_issuer"
      end
      # verify the required parameter 'signer_key_name' is set
      if @api_client.config.client_side_validation && signer_key_name.nil?
        fail ArgumentError, "Missing the required parameter 'signer_key_name' when calling DefaultApi.create_pki_cert_issuer"
      end
      # verify the required parameter 'ttl' is set
      if @api_client.config.client_side_validation && ttl.nil?
        fail ArgumentError, "Missing the required parameter 'ttl' when calling DefaultApi.create_pki_cert_issuer"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_pki_cert_issuer"
      end
      # resource path
      local_var_path = '/create-pki-cert-issuer'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'signer-key-name'] = signer_key_name
      query_params[:'ttl'] = ttl
      query_params[:'token'] = token
      query_params[:'allowed-domains'] = opts[:'allowed_domains'] if !opts[:'allowed_domains'].nil?
      query_params[:'allowed-uri-sans'] = opts[:'allowed_uri_sans'] if !opts[:'allowed_uri_sans'].nil?
      query_params[:'allow-subdomains'] = opts[:'allow_subdomains'] if !opts[:'allow_subdomains'].nil?
      query_params[:'not-enforce-hostnames'] = opts[:'not_enforce_hostnames'] if !opts[:'not_enforce_hostnames'].nil?
      query_params[:'allow-any-name'] = opts[:'allow_any_name'] if !opts[:'allow_any_name'].nil?
      query_params[:'not-require-cn'] = opts[:'not_require_cn'] if !opts[:'not_require_cn'].nil?
      query_params[:'server-flag'] = opts[:'server_flag'] if !opts[:'server_flag'].nil?
      query_params[:'client-flag'] = opts[:'client_flag'] if !opts[:'client_flag'].nil?
      query_params[:'code-signing-flag'] = opts[:'code_signing_flag'] if !opts[:'code_signing_flag'].nil?
      query_params[:'key-usage'] = opts[:'key_usage'] if !opts[:'key_usage'].nil?
      query_params[:'organization-units'] = opts[:'organization_units'] if !opts[:'organization_units'].nil?
      query_params[:'organizations'] = opts[:'organizations'] if !opts[:'organizations'].nil?
      query_params[:'country'] = opts[:'country'] if !opts[:'country'].nil?
      query_params[:'locality'] = opts[:'locality'] if !opts[:'locality'].nil?
      query_params[:'province'] = opts[:'province'] if !opts[:'province'].nil?
      query_params[:'street-address'] = opts[:'street_address'] if !opts[:'street_address'].nil?
      query_params[:'postal-code'] = opts[:'postal_code'] if !opts[:'postal_code'].nil?
      query_params[:'metadata'] = opts[:'metadata'] if !opts[:'metadata'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_pki_cert_issuer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new role
    # Creates a new role Options:   name -    Role name   comment -    Comment about the role   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :comment Comment about the role
    # @return [ReplyObj]
    def create_role(name, token, opts = {})
      data, _status_code, _headers = create_role_with_http_info(name, token, opts)
      data
    end

    # Creates a new role
    # Creates a new role Options:   name -    Role name   comment -    Comment about the role   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :comment Comment about the role
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_role_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_role ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_role"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_role"
      end
      # resource path
      local_var_path = '/create-role'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token
      query_params[:'comment'] = opts[:'comment'] if !opts[:'comment'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_role\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new secret item
    # Creates a new secret item Options:   name -    Secret name   value -    The secret value   metadata -    Metadata about the secret   tag -    List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   key -    The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)   multiline -    The provided value is a multiline value (separated by '\\n')   token -    Access token
    # @param name Secret name
    # @param value The secret value
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata Metadata about the secret
    # @option opts [String] :tag List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :key The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)
    # @option opts [BOOLEAN] :multiline The provided value is a multiline value (separated by &#39;\\n&#39;)
    # @return [ReplyObj]
    def create_secret(name, value, token, opts = {})
      data, _status_code, _headers = create_secret_with_http_info(name, value, token, opts)
      data
    end

    # Creates a new secret item
    # Creates a new secret item Options:   name -    Secret name   value -    The secret value   metadata -    Metadata about the secret   tag -    List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   key -    The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)   multiline -    The provided value is a multiline value (separated by &#39;\\n&#39;)   token -    Access token
    # @param name Secret name
    # @param value The secret value
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata Metadata about the secret
    # @option opts [String] :tag List of the tags attached to this secret. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :key The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)
    # @option opts [BOOLEAN] :multiline The provided value is a multiline value (separated by &#39;\\n&#39;)
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_secret_with_http_info(name, value, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_secret ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_secret"
      end
      # verify the required parameter 'value' is set
      if @api_client.config.client_side_validation && value.nil?
        fail ArgumentError, "Missing the required parameter 'value' when calling DefaultApi.create_secret"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_secret"
      end
      # resource path
      local_var_path = '/create-secret'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'value'] = value
      query_params[:'token'] = token
      query_params[:'metadata'] = opts[:'metadata'] if !opts[:'metadata'].nil?
      query_params[:'tag'] = opts[:'tag'] if !opts[:'tag'].nil?
      query_params[:'key'] = opts[:'key'] if !opts[:'key'].nil?
      query_params[:'multiline'] = opts[:'multiline'] if !opts[:'multiline'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_secret\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Creates a new SSH certificate issuer
    # Creates a new SSH certificate issuer Options:   name -    SSH certificate issuer name   signer-key-name -    A key to sign the certificate with   allowed-users -    Users allowed to fetch the certificate, ex. root,ubuntu   principals -    Signed certificates with principal, ex. example_role1,example_role2   extensions -    Signed certificates with extensions, ex. permit-port-forwarding=\"\"   ttl -    The requested Time To Live for the certificate, use second units   metadata -    A metadata about the issuer   token -    Access token
    # @param name SSH certificate issuer name
    # @param signer_key_name A key to sign the certificate with
    # @param allowed_users Users allowed to fetch the certificate, ex. root,ubuntu
    # @param ttl The requested Time To Live for the certificate, use second units
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :principals Signed certificates with principal, ex. example_role1,example_role2
    # @option opts [String] :extensions Signed certificates with extensions, ex. permit-port-forwarding&#x3D;\&quot;\&quot;
    # @option opts [String] :metadata A metadata about the issuer
    # @return [ReplyObj]
    def create_ssh_cert_issuer(name, signer_key_name, allowed_users, ttl, token, opts = {})
      data, _status_code, _headers = create_ssh_cert_issuer_with_http_info(name, signer_key_name, allowed_users, ttl, token, opts)
      data
    end

    # Creates a new SSH certificate issuer
    # Creates a new SSH certificate issuer Options:   name -    SSH certificate issuer name   signer-key-name -    A key to sign the certificate with   allowed-users -    Users allowed to fetch the certificate, ex. root,ubuntu   principals -    Signed certificates with principal, ex. example_role1,example_role2   extensions -    Signed certificates with extensions, ex. permit-port-forwarding&#x3D;\&quot;\&quot;   ttl -    The requested Time To Live for the certificate, use second units   metadata -    A metadata about the issuer   token -    Access token
    # @param name SSH certificate issuer name
    # @param signer_key_name A key to sign the certificate with
    # @param allowed_users Users allowed to fetch the certificate, ex. root,ubuntu
    # @param ttl The requested Time To Live for the certificate, use second units
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :principals Signed certificates with principal, ex. example_role1,example_role2
    # @option opts [String] :extensions Signed certificates with extensions, ex. permit-port-forwarding&#x3D;\&quot;\&quot;
    # @option opts [String] :metadata A metadata about the issuer
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def create_ssh_cert_issuer_with_http_info(name, signer_key_name, allowed_users, ttl, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_ssh_cert_issuer ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.create_ssh_cert_issuer"
      end
      # verify the required parameter 'signer_key_name' is set
      if @api_client.config.client_side_validation && signer_key_name.nil?
        fail ArgumentError, "Missing the required parameter 'signer_key_name' when calling DefaultApi.create_ssh_cert_issuer"
      end
      # verify the required parameter 'allowed_users' is set
      if @api_client.config.client_side_validation && allowed_users.nil?
        fail ArgumentError, "Missing the required parameter 'allowed_users' when calling DefaultApi.create_ssh_cert_issuer"
      end
      # verify the required parameter 'ttl' is set
      if @api_client.config.client_side_validation && ttl.nil?
        fail ArgumentError, "Missing the required parameter 'ttl' when calling DefaultApi.create_ssh_cert_issuer"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.create_ssh_cert_issuer"
      end
      # resource path
      local_var_path = '/create-ssh-cert-issuer'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'signer-key-name'] = signer_key_name
      query_params[:'allowed-users'] = allowed_users
      query_params[:'ttl'] = ttl
      query_params[:'token'] = token
      query_params[:'principals'] = opts[:'principals'] if !opts[:'principals'].nil?
      query_params[:'extensions'] = opts[:'extensions'] if !opts[:'extensions'].nil?
      query_params[:'metadata'] = opts[:'metadata'] if !opts[:'metadata'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_ssh_cert_issuer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Decrypts ciphertext into plaintext by using an AES key
    # Decrypts ciphertext into plaintext by using an AES key Options:   key-name -    The name of the key to use in the decryption process   ciphertext -    Ciphertext to be decrypted in base64 encoded format   encryption-context -    The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail   token -    Access token
    # @param key_name The name of the key to use in the decryption process
    # @param ciphertext Ciphertext to be decrypted in base64 encoded format
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :encryption_context The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail
    # @return [ReplyObj]
    def decrypt(key_name, ciphertext, token, opts = {})
      data, _status_code, _headers = decrypt_with_http_info(key_name, ciphertext, token, opts)
      data
    end

    # Decrypts ciphertext into plaintext by using an AES key
    # Decrypts ciphertext into plaintext by using an AES key Options:   key-name -    The name of the key to use in the decryption process   ciphertext -    Ciphertext to be decrypted in base64 encoded format   encryption-context -    The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail   token -    Access token
    # @param key_name The name of the key to use in the decryption process
    # @param ciphertext Ciphertext to be decrypted in base64 encoded format
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :encryption_context The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def decrypt_with_http_info(key_name, ciphertext, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.decrypt ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.decrypt"
      end
      # verify the required parameter 'ciphertext' is set
      if @api_client.config.client_side_validation && ciphertext.nil?
        fail ArgumentError, "Missing the required parameter 'ciphertext' when calling DefaultApi.decrypt"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.decrypt"
      end
      # resource path
      local_var_path = '/decrypt'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'ciphertext'] = ciphertext
      query_params[:'token'] = token
      query_params[:'encryption-context'] = opts[:'encryption_context'] if !opts[:'encryption_context'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#decrypt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Decrypts a file by using an AES key
    # Decrypts a file by using an AES key Options:   key-name -    The name of the key to use in the decryption process   in -    Path to the file to be decrypted. If not provided, the content will be taken from stdin   out -    Path to the output file. If not provided, the output will be sent to stdout   encryption-context -    The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail   token -    Access token
    # @param key_name The name of the key to use in the decryption process
    # @param _in Path to the file to be decrypted. If not provided, the content will be taken from stdin
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :out Path to the output file. If not provided, the output will be sent to stdout
    # @option opts [String] :encryption_context The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail
    # @return [ReplyObj]
    def decrypt_file(key_name, _in, token, opts = {})
      data, _status_code, _headers = decrypt_file_with_http_info(key_name, _in, token, opts)
      data
    end

    # Decrypts a file by using an AES key
    # Decrypts a file by using an AES key Options:   key-name -    The name of the key to use in the decryption process   in -    Path to the file to be decrypted. If not provided, the content will be taken from stdin   out -    Path to the output file. If not provided, the output will be sent to stdout   encryption-context -    The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail   token -    Access token
    # @param key_name The name of the key to use in the decryption process
    # @param _in Path to the file to be decrypted. If not provided, the content will be taken from stdin
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :out Path to the output file. If not provided, the output will be sent to stdout
    # @option opts [String] :encryption_context The encryption context. If this was specified in the encrypt command, it must be specified here or the decryption operation will fail
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def decrypt_file_with_http_info(key_name, _in, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.decrypt_file ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.decrypt_file"
      end
      # verify the required parameter '_in' is set
      if @api_client.config.client_side_validation && _in.nil?
        fail ArgumentError, "Missing the required parameter '_in' when calling DefaultApi.decrypt_file"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.decrypt_file"
      end
      # resource path
      local_var_path = '/decrypt-file'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'in'] = _in
      query_params[:'token'] = token
      query_params[:'out'] = opts[:'out'] if !opts[:'out'].nil?
      query_params[:'encryption-context'] = opts[:'encryption_context'] if !opts[:'encryption_context'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#decrypt_file\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5
    # Decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5 Options:   key-name -    The name of the RSA key to use in the decryption process   ciphertext -    Ciphertext to be decrypted in base64 encoded format   token -    Access token
    # @param key_name The name of the RSA key to use in the decryption process
    # @param ciphertext Ciphertext to be decrypted in base64 encoded format
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def decrypt_pkcs1(key_name, ciphertext, token, opts = {})
      data, _status_code, _headers = decrypt_pkcs1_with_http_info(key_name, ciphertext, token, opts)
      data
    end

    # Decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5
    # Decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5 Options:   key-name -    The name of the RSA key to use in the decryption process   ciphertext -    Ciphertext to be decrypted in base64 encoded format   token -    Access token
    # @param key_name The name of the RSA key to use in the decryption process
    # @param ciphertext Ciphertext to be decrypted in base64 encoded format
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def decrypt_pkcs1_with_http_info(key_name, ciphertext, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.decrypt_pkcs1 ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.decrypt_pkcs1"
      end
      # verify the required parameter 'ciphertext' is set
      if @api_client.config.client_side_validation && ciphertext.nil?
        fail ArgumentError, "Missing the required parameter 'ciphertext' when calling DefaultApi.decrypt_pkcs1"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.decrypt_pkcs1"
      end
      # resource path
      local_var_path = '/decrypt-pkcs1'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'ciphertext'] = ciphertext
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#decrypt_pkcs1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete an association between role and auth method
    # Delete an association between role and auth method Options:   assoc-id -    The association id to be deleted   token -    Access token
    # @param assoc_id The association id to be deleted
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def delete_assoc(assoc_id, token, opts = {})
      data, _status_code, _headers = delete_assoc_with_http_info(assoc_id, token, opts)
      data
    end

    # Delete an association between role and auth method
    # Delete an association between role and auth method Options:   assoc-id -    The association id to be deleted   token -    Access token
    # @param assoc_id The association id to be deleted
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def delete_assoc_with_http_info(assoc_id, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_assoc ...'
      end
      # verify the required parameter 'assoc_id' is set
      if @api_client.config.client_side_validation && assoc_id.nil?
        fail ArgumentError, "Missing the required parameter 'assoc_id' when calling DefaultApi.delete_assoc"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.delete_assoc"
      end
      # resource path
      local_var_path = '/delete-assoc'

      # query parameters
      query_params = {}
      query_params[:'assoc-id'] = assoc_id
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_assoc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete the Auth Method
    # Delete the Auth Method Options:   name -    Auth Method name   token -    Access token
    # @param name Auth Method name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def delete_auth_method(name, token, opts = {})
      data, _status_code, _headers = delete_auth_method_with_http_info(name, token, opts)
      data
    end

    # Delete the Auth Method
    # Delete the Auth Method Options:   name -    Auth Method name   token -    Access token
    # @param name Auth Method name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def delete_auth_method_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_auth_method ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_auth_method"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.delete_auth_method"
      end
      # resource path
      local_var_path = '/delete-auth-method'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_auth_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete an item or an item version
    # Delete an item or an item version Options:   name -    Item name   token -    Access token
    # @param name Item name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def delete_item(name, token, opts = {})
      data, _status_code, _headers = delete_item_with_http_info(name, token, opts)
      data
    end

    # Delete an item or an item version
    # Delete an item or an item version Options:   name -    Item name   token -    Access token
    # @param name Item name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def delete_item_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_item ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_item"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.delete_item"
      end
      # resource path
      local_var_path = '/delete-item'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a role
    # Delete a role Options:   name -    Role name   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def delete_role(name, token, opts = {})
      data, _status_code, _headers = delete_role_with_http_info(name, token, opts)
      data
    end

    # Delete a role
    # Delete a role Options:   name -    Role name   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def delete_role_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_role ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_role"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.delete_role"
      end
      # resource path
      local_var_path = '/delete-role'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_role\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a rule from a role
    # Delete a rule from a role Options:   role-name -    The role name to be updated   path -    The path the rule refers to   token -    Access token
    # @param role_name The role name to be updated
    # @param path The path the rule refers to
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def delete_role_rule(role_name, path, token, opts = {})
      data, _status_code, _headers = delete_role_rule_with_http_info(role_name, path, token, opts)
      data
    end

    # Delete a rule from a role
    # Delete a rule from a role Options:   role-name -    The role name to be updated   path -    The path the rule refers to   token -    Access token
    # @param role_name The role name to be updated
    # @param path The path the rule refers to
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def delete_role_rule_with_http_info(role_name, path, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_role_rule ...'
      end
      # verify the required parameter 'role_name' is set
      if @api_client.config.client_side_validation && role_name.nil?
        fail ArgumentError, "Missing the required parameter 'role_name' when calling DefaultApi.delete_role_rule"
      end
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling DefaultApi.delete_role_rule"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.delete_role_rule"
      end
      # resource path
      local_var_path = '/delete-role-rule'

      # query parameters
      query_params = {}
      query_params[:'role-name'] = role_name
      query_params[:'path'] = path
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_role_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns the item details
    # Returns the item details Options:   name -    Item name   token -    Access token
    # @param name Item name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def describe_item(name, token, opts = {})
      data, _status_code, _headers = describe_item_with_http_info(name, token, opts)
      data
    end

    # Returns the item details
    # Returns the item details Options:   name -    Item name   token -    Access token
    # @param name Item name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def describe_item_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.describe_item ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.describe_item"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.describe_item"
      end
      # resource path
      local_var_path = '/describe-item'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#describe_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Encrypts plaintext into ciphertext by using an AES key
    # Encrypts plaintext into ciphertext by using an AES key Options:   key-name -    The name of the key to use in the encryption process   plaintext -    Data to be encrypted   encryption-context -    name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail   token -    Access token
    # @param key_name The name of the key to use in the encryption process
    # @param plaintext Data to be encrypted
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :encryption_context name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail
    # @return [ReplyObj]
    def encrypt(key_name, plaintext, token, opts = {})
      data, _status_code, _headers = encrypt_with_http_info(key_name, plaintext, token, opts)
      data
    end

    # Encrypts plaintext into ciphertext by using an AES key
    # Encrypts plaintext into ciphertext by using an AES key Options:   key-name -    The name of the key to use in the encryption process   plaintext -    Data to be encrypted   encryption-context -    name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail   token -    Access token
    # @param key_name The name of the key to use in the encryption process
    # @param plaintext Data to be encrypted
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :encryption_context name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def encrypt_with_http_info(key_name, plaintext, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.encrypt ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.encrypt"
      end
      # verify the required parameter 'plaintext' is set
      if @api_client.config.client_side_validation && plaintext.nil?
        fail ArgumentError, "Missing the required parameter 'plaintext' when calling DefaultApi.encrypt"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.encrypt"
      end
      # resource path
      local_var_path = '/encrypt'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'plaintext'] = plaintext
      query_params[:'token'] = token
      query_params[:'encryption-context'] = opts[:'encryption_context'] if !opts[:'encryption_context'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#encrypt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Encrypts a file by using an AES key
    # Encrypts a file by using an AES key Options:   key-name -    The name of the key to use in the encryption process   in -    Path to the file to be encrypted. If not provided, the content will be taken from stdin   out -    Path to the output file. If not provided, the output will be sent to stdout   encryption-context -    name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail   token -    Access token
    # @param key_name The name of the key to use in the encryption process
    # @param _in Path to the file to be encrypted. If not provided, the content will be taken from stdin
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :out Path to the output file. If not provided, the output will be sent to stdout
    # @option opts [String] :encryption_context name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail
    # @return [ReplyObj]
    def encrypt_file(key_name, _in, token, opts = {})
      data, _status_code, _headers = encrypt_file_with_http_info(key_name, _in, token, opts)
      data
    end

    # Encrypts a file by using an AES key
    # Encrypts a file by using an AES key Options:   key-name -    The name of the key to use in the encryption process   in -    Path to the file to be encrypted. If not provided, the content will be taken from stdin   out -    Path to the output file. If not provided, the output will be sent to stdout   encryption-context -    name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail   token -    Access token
    # @param key_name The name of the key to use in the encryption process
    # @param _in Path to the file to be encrypted. If not provided, the content will be taken from stdin
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :out Path to the output file. If not provided, the output will be sent to stdout
    # @option opts [String] :encryption_context name-value pair that specifies the encryption context to be used for authenticated encryption. If used here, the same value must be supplied to the decrypt command or decryption will fail
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def encrypt_file_with_http_info(key_name, _in, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.encrypt_file ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.encrypt_file"
      end
      # verify the required parameter '_in' is set
      if @api_client.config.client_side_validation && _in.nil?
        fail ArgumentError, "Missing the required parameter '_in' when calling DefaultApi.encrypt_file"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.encrypt_file"
      end
      # resource path
      local_var_path = '/encrypt-file'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'in'] = _in
      query_params[:'token'] = token
      query_params[:'out'] = opts[:'out'] if !opts[:'out'].nil?
      query_params[:'encryption-context'] = opts[:'encryption_context'] if !opts[:'encryption_context'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#encrypt_file\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5
    # Encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5 Options:   key-name -    The name of the RSA key to use in the encryption process   plaintext -    Data to be encrypted   token -    Access token
    # @param key_name The name of the RSA key to use in the encryption process
    # @param plaintext Data to be encrypted
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def encrypt_pkcs1(key_name, plaintext, token, opts = {})
      data, _status_code, _headers = encrypt_pkcs1_with_http_info(key_name, plaintext, token, opts)
      data
    end

    # Encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5
    # Encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5 Options:   key-name -    The name of the RSA key to use in the encryption process   plaintext -    Data to be encrypted   token -    Access token
    # @param key_name The name of the RSA key to use in the encryption process
    # @param plaintext Data to be encrypted
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def encrypt_pkcs1_with_http_info(key_name, plaintext, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.encrypt_pkcs1 ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.encrypt_pkcs1"
      end
      # verify the required parameter 'plaintext' is set
      if @api_client.config.client_side_validation && plaintext.nil?
        fail ArgumentError, "Missing the required parameter 'plaintext' when calling DefaultApi.encrypt_pkcs1"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.encrypt_pkcs1"
      end
      # resource path
      local_var_path = '/encrypt-pkcs1'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'plaintext'] = plaintext
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#encrypt_pkcs1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns an information about the Auth Method
    # Returns an information about the Auth Method Options:   name -    Auth Method name   token -    Access token
    # @param name Auth Method name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def get_auth_method(name, token, opts = {})
      data, _status_code, _headers = get_auth_method_with_http_info(name, token, opts)
      data
    end

    # Returns an information about the Auth Method
    # Returns an information about the Auth Method Options:   name -    Auth Method name   token -    Access token
    # @param name Auth Method name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_auth_method_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_auth_method ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.get_auth_method"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_auth_method"
      end
      # resource path
      local_var_path = '/get-auth-method'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_auth_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get Cloud Identity Token (relevant only for access-type=azure_ad,aws_iam)
    # Get Cloud Identity Token (relevant only for access-type=azure_ad,aws_iam) Options:   azure_ad_object_id -    Azure Active Directory ObjectId (relevant only for access-type=azure_ad)   url_safe -    escapes the token so it can be safely placed inside a URL query   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :azure_ad_object_id Azure Active Directory ObjectId (relevant only for access-type&#x3D;azure_ad)
    # @option opts [String] :url_safe escapes the token so it can be safely placed inside a URL query
    # @return [ReplyObj]
    def get_cloud_identity(token, opts = {})
      data, _status_code, _headers = get_cloud_identity_with_http_info(token, opts)
      data
    end

    # Get Cloud Identity Token (relevant only for access-type&#x3D;azure_ad,aws_iam)
    # Get Cloud Identity Token (relevant only for access-type&#x3D;azure_ad,aws_iam) Options:   azure_ad_object_id -    Azure Active Directory ObjectId (relevant only for access-type&#x3D;azure_ad)   url_safe -    escapes the token so it can be safely placed inside a URL query   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :azure_ad_object_id Azure Active Directory ObjectId (relevant only for access-type&#x3D;azure_ad)
    # @option opts [String] :url_safe escapes the token so it can be safely placed inside a URL query
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_cloud_identity_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cloud_identity ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_cloud_identity"
      end
      # resource path
      local_var_path = '/get-cloud-identity'

      # query parameters
      query_params = {}
      query_params[:'token'] = token
      query_params[:'azure_ad_object_id'] = opts[:'azure_ad_object_id'] if !opts[:'azure_ad_object_id'].nil?
      query_params[:'url_safe'] = opts[:'url_safe'] if !opts[:'url_safe'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cloud_identity\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get dynamic secret value
    # Get dynamic secret value Options:   name -    Dynamic secret name   token -    Access token
    # @param name Dynamic secret name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def get_dynamic_secret_value(name, token, opts = {})
      data, _status_code, _headers = get_dynamic_secret_value_with_http_info(name, token, opts)
      data
    end

    # Get dynamic secret value
    # Get dynamic secret value Options:   name -    Dynamic secret name   token -    Access token
    # @param name Dynamic secret name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_dynamic_secret_value_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_dynamic_secret_value ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.get_dynamic_secret_value"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_dynamic_secret_value"
      end
      # resource path
      local_var_path = '/get-dynamic-secret-value'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_dynamic_secret_value\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get credentials for authentication with Kubernetes cluster based on a PKI Cert Issuer
    # Get credentials for authentication with Kubernetes cluster based on a PKI Cert Issuer Options:   cert-issuer-name -    The name of the PKI certificate issuer   key-file-path -    The client public or private key file path (in case of a private key, it will be use to extract the public key)   common-name -    The common name to be included in the PKI certificate   alt-names -    The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   uri-sans -    The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   outfile -    Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension   token -    Access token
    # @param cert_issuer_name The name of the PKI certificate issuer
    # @param key_file_path The client public or private key file path (in case of a private key, it will be use to extract the public key)
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :common_name The common name to be included in the PKI certificate
    # @option opts [String] :alt_names The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :uri_sans The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :outfile Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension
    # @return [ReplyObj]
    def get_kube_exec_creds(cert_issuer_name, key_file_path, token, opts = {})
      data, _status_code, _headers = get_kube_exec_creds_with_http_info(cert_issuer_name, key_file_path, token, opts)
      data
    end

    # Get credentials for authentication with Kubernetes cluster based on a PKI Cert Issuer
    # Get credentials for authentication with Kubernetes cluster based on a PKI Cert Issuer Options:   cert-issuer-name -    The name of the PKI certificate issuer   key-file-path -    The client public or private key file path (in case of a private key, it will be use to extract the public key)   common-name -    The common name to be included in the PKI certificate   alt-names -    The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   uri-sans -    The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   outfile -    Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension   token -    Access token
    # @param cert_issuer_name The name of the PKI certificate issuer
    # @param key_file_path The client public or private key file path (in case of a private key, it will be use to extract the public key)
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :common_name The common name to be included in the PKI certificate
    # @option opts [String] :alt_names The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :uri_sans The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :outfile Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_kube_exec_creds_with_http_info(cert_issuer_name, key_file_path, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_kube_exec_creds ...'
      end
      # verify the required parameter 'cert_issuer_name' is set
      if @api_client.config.client_side_validation && cert_issuer_name.nil?
        fail ArgumentError, "Missing the required parameter 'cert_issuer_name' when calling DefaultApi.get_kube_exec_creds"
      end
      # verify the required parameter 'key_file_path' is set
      if @api_client.config.client_side_validation && key_file_path.nil?
        fail ArgumentError, "Missing the required parameter 'key_file_path' when calling DefaultApi.get_kube_exec_creds"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_kube_exec_creds"
      end
      # resource path
      local_var_path = '/get-kube-exec-creds'

      # query parameters
      query_params = {}
      query_params[:'cert-issuer-name'] = cert_issuer_name
      query_params[:'key-file-path'] = key_file_path
      query_params[:'token'] = token
      query_params[:'common-name'] = opts[:'common_name'] if !opts[:'common_name'].nil?
      query_params[:'alt-names'] = opts[:'alt_names'] if !opts[:'alt_names'].nil?
      query_params[:'uri-sans'] = opts[:'uri_sans'] if !opts[:'uri_sans'].nil?
      query_params[:'outfile'] = opts[:'outfile'] if !opts[:'outfile'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_kube_exec_creds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generates PKI certificate
    # Generates PKI certificate Options:   cert-issuer-name -    The name of the PKI certificate issuer   key-file-path -    The client public or private key file path (in case of a private key, it will be use to extract the public key)   common-name -    The common name to be included in the PKI certificate   alt-names -    The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   uri-sans -    The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   outfile -    Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension   token -    Access token
    # @param cert_issuer_name The name of the PKI certificate issuer
    # @param key_file_path The client public or private key file path (in case of a private key, it will be use to extract the public key)
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :common_name The common name to be included in the PKI certificate
    # @option opts [String] :alt_names The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :uri_sans The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :outfile Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension
    # @return [ReplyObj]
    def get_pki_certificate(cert_issuer_name, key_file_path, token, opts = {})
      data, _status_code, _headers = get_pki_certificate_with_http_info(cert_issuer_name, key_file_path, token, opts)
      data
    end

    # Generates PKI certificate
    # Generates PKI certificate Options:   cert-issuer-name -    The name of the PKI certificate issuer   key-file-path -    The client public or private key file path (in case of a private key, it will be use to extract the public key)   common-name -    The common name to be included in the PKI certificate   alt-names -    The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   uri-sans -    The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)   outfile -    Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension   token -    Access token
    # @param cert_issuer_name The name of the PKI certificate issuer
    # @param key_file_path The client public or private key file path (in case of a private key, it will be use to extract the public key)
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :common_name The common name to be included in the PKI certificate
    # @option opts [String] :alt_names The Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :uri_sans The URI Subject Alternative Names to be included in the PKI certificate (in a comma-delimited list)
    # @option opts [String] :outfile Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_pki_certificate_with_http_info(cert_issuer_name, key_file_path, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_pki_certificate ...'
      end
      # verify the required parameter 'cert_issuer_name' is set
      if @api_client.config.client_side_validation && cert_issuer_name.nil?
        fail ArgumentError, "Missing the required parameter 'cert_issuer_name' when calling DefaultApi.get_pki_certificate"
      end
      # verify the required parameter 'key_file_path' is set
      if @api_client.config.client_side_validation && key_file_path.nil?
        fail ArgumentError, "Missing the required parameter 'key_file_path' when calling DefaultApi.get_pki_certificate"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_pki_certificate"
      end
      # resource path
      local_var_path = '/get-pki-certificate'

      # query parameters
      query_params = {}
      query_params[:'cert-issuer-name'] = cert_issuer_name
      query_params[:'key-file-path'] = key_file_path
      query_params[:'token'] = token
      query_params[:'common-name'] = opts[:'common_name'] if !opts[:'common_name'].nil?
      query_params[:'alt-names'] = opts[:'alt_names'] if !opts[:'alt_names'].nil?
      query_params[:'uri-sans'] = opts[:'uri_sans'] if !opts[:'uri_sans'].nil?
      query_params[:'outfile'] = opts[:'outfile'] if !opts[:'outfile'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_pki_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get role details
    # Get role details Options:   name -    Role name   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def get_role(name, token, opts = {})
      data, _status_code, _headers = get_role_with_http_info(name, token, opts)
      data
    end

    # Get role details
    # Get role details Options:   name -    Role name   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_role_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_role ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.get_role"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_role"
      end
      # resource path
      local_var_path = '/get-role'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_role\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Obtain the public key from a specific RSA private key
    # Obtain the public key from a specific RSA private key Options:   name -    Name of key to be created   token -    Access token
    # @param name Name of key to be created
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def get_rsa_public(name, token, opts = {})
      data, _status_code, _headers = get_rsa_public_with_http_info(name, token, opts)
      data
    end

    # Obtain the public key from a specific RSA private key
    # Obtain the public key from a specific RSA private key Options:   name -    Name of key to be created   token -    Access token
    # @param name Name of key to be created
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_rsa_public_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_rsa_public ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.get_rsa_public"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_rsa_public"
      end
      # resource path
      local_var_path = '/get-rsa-public'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_rsa_public\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get static secret value
    # Get static secret value Options:   name -    Secret name   token -    Access token
    # @param name Secret name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def get_secret_value(name, token, opts = {})
      data, _status_code, _headers = get_secret_value_with_http_info(name, token, opts)
      data
    end

    # Get static secret value
    # Get static secret value Options:   name -    Secret name   token -    Access token
    # @param name Secret name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_secret_value_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_secret_value ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.get_secret_value"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_secret_value"
      end
      # resource path
      local_var_path = '/get-secret-value'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_secret_value\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Generates SSH certificate
    # Generates SSH certificate Options:   cert-username -    The username to sign in the SSH certificate   cert-issuer-name -    The name of the SSH certificate issuer   public-key-file-path -    SSH public key   outfile -    Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension   token -    Access token
    # @param cert_username The username to sign in the SSH certificate
    # @param cert_issuer_name The name of the SSH certificate issuer
    # @param public_key_file_path SSH public key
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :outfile Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension
    # @return [ReplyObj]
    def get_ssh_certificate(cert_username, cert_issuer_name, public_key_file_path, token, opts = {})
      data, _status_code, _headers = get_ssh_certificate_with_http_info(cert_username, cert_issuer_name, public_key_file_path, token, opts)
      data
    end

    # Generates SSH certificate
    # Generates SSH certificate Options:   cert-username -    The username to sign in the SSH certificate   cert-issuer-name -    The name of the SSH certificate issuer   public-key-file-path -    SSH public key   outfile -    Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension   token -    Access token
    # @param cert_username The username to sign in the SSH certificate
    # @param cert_issuer_name The name of the SSH certificate issuer
    # @param public_key_file_path SSH public key
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :outfile Output file path with the certificate. If not provided, the file with the certificate will be created in the same location of the provided public key with the -cert extension
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def get_ssh_certificate_with_http_info(cert_username, cert_issuer_name, public_key_file_path, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_ssh_certificate ...'
      end
      # verify the required parameter 'cert_username' is set
      if @api_client.config.client_side_validation && cert_username.nil?
        fail ArgumentError, "Missing the required parameter 'cert_username' when calling DefaultApi.get_ssh_certificate"
      end
      # verify the required parameter 'cert_issuer_name' is set
      if @api_client.config.client_side_validation && cert_issuer_name.nil?
        fail ArgumentError, "Missing the required parameter 'cert_issuer_name' when calling DefaultApi.get_ssh_certificate"
      end
      # verify the required parameter 'public_key_file_path' is set
      if @api_client.config.client_side_validation && public_key_file_path.nil?
        fail ArgumentError, "Missing the required parameter 'public_key_file_path' when calling DefaultApi.get_ssh_certificate"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.get_ssh_certificate"
      end
      # resource path
      local_var_path = '/get-ssh-certificate'

      # query parameters
      query_params = {}
      query_params[:'cert-username'] = cert_username
      query_params[:'cert-issuer-name'] = cert_issuer_name
      query_params[:'public-key-file-path'] = public_key_file_path
      query_params[:'token'] = token
      query_params[:'outfile'] = opts[:'outfile'] if !opts[:'outfile'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_ssh_certificate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # help text
    # help text
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def help(opts = {})
      data, _status_code, _headers = help_with_http_info(opts)
      data
    end

    # help text
    # help text
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def help_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.help ...'
      end
      # resource path
      local_var_path = '/help'

      # query parameters
      query_params = {}

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#help\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns a list of all the Auth Methods in the account
    # Returns a list of all the Auth Methods in the account Options:   pagination-token -    Next page reference   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :pagination_token Next page reference
    # @return [ReplyObj]
    def list_auth_methods(token, opts = {})
      data, _status_code, _headers = list_auth_methods_with_http_info(token, opts)
      data
    end

    # Returns a list of all the Auth Methods in the account
    # Returns a list of all the Auth Methods in the account Options:   pagination-token -    Next page reference   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :pagination_token Next page reference
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def list_auth_methods_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_auth_methods ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.list_auth_methods"
      end
      # resource path
      local_var_path = '/list-auth-methods'

      # query parameters
      query_params = {}
      query_params[:'token'] = token
      query_params[:'pagination-token'] = opts[:'pagination_token'] if !opts[:'pagination_token'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_auth_methods\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns a list of all accessible items
    # Returns a list of all accessible items Options:   type -    The item types list of the requested items. In case it is empty, all types of items will be returned. options- [key, static-secret, dynamic-secret]   ItemsTypes -    ItemsTypes   filter -    Filter by item name or part of it   tag -    Filter by item tag   path -    Path to folder   pagination-token -    Next page reference   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type The item types list of the requested items. In case it is empty, all types of items will be returned. options- [key, static-secret, dynamic-secret]
    # @option opts [String] :items_types ItemsTypes
    # @option opts [String] :filter Filter by item name or part of it
    # @option opts [String] :tag Filter by item tag
    # @option opts [String] :path Path to folder
    # @option opts [String] :pagination_token Next page reference
    # @return [ReplyObj]
    def list_items(token, opts = {})
      data, _status_code, _headers = list_items_with_http_info(token, opts)
      data
    end

    # Returns a list of all accessible items
    # Returns a list of all accessible items Options:   type -    The item types list of the requested items. In case it is empty, all types of items will be returned. options- [key, static-secret, dynamic-secret]   ItemsTypes -    ItemsTypes   filter -    Filter by item name or part of it   tag -    Filter by item tag   path -    Path to folder   pagination-token -    Next page reference   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :type The item types list of the requested items. In case it is empty, all types of items will be returned. options- [key, static-secret, dynamic-secret]
    # @option opts [String] :items_types ItemsTypes
    # @option opts [String] :filter Filter by item name or part of it
    # @option opts [String] :tag Filter by item tag
    # @option opts [String] :path Path to folder
    # @option opts [String] :pagination_token Next page reference
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def list_items_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_items ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.list_items"
      end
      # resource path
      local_var_path = '/list-items'

      # query parameters
      query_params = {}
      query_params[:'token'] = token
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?
      query_params[:'ItemsTypes'] = opts[:'items_types'] if !opts[:'items_types'].nil?
      query_params[:'filter'] = opts[:'filter'] if !opts[:'filter'].nil?
      query_params[:'tag'] = opts[:'tag'] if !opts[:'tag'].nil?
      query_params[:'path'] = opts[:'path'] if !opts[:'path'].nil?
      query_params[:'pagination-token'] = opts[:'pagination_token'] if !opts[:'pagination_token'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Returns a list of all roles in the account
    # Returns a list of all roles in the account Options:   pagination-token -    Next page reference   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :pagination_token Next page reference
    # @return [ReplyObj]
    def list_roles(token, opts = {})
      data, _status_code, _headers = list_roles_with_http_info(token, opts)
      data
    end

    # Returns a list of all roles in the account
    # Returns a list of all roles in the account Options:   pagination-token -    Next page reference   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :pagination_token Next page reference
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def list_roles_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_roles ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.list_roles"
      end
      # resource path
      local_var_path = '/list-roles'

      # query parameters
      query_params = {}
      query_params[:'token'] = token
      query_params[:'pagination-token'] = opts[:'pagination_token'] if !opts[:'pagination_token'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_roles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # See which authentication methods have access to a particular object
    # See which authentication methods have access to a particular object Options:   path -    Path to an object   type -    Type of object (item, am, role)   token -    Access token
    # @param path Path to an object
    # @param type Type of object (item, am, role)
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def reverse_rbac(path, type, token, opts = {})
      data, _status_code, _headers = reverse_rbac_with_http_info(path, type, token, opts)
      data
    end

    # See which authentication methods have access to a particular object
    # See which authentication methods have access to a particular object Options:   path -    Path to an object   type -    Type of object (item, am, role)   token -    Access token
    # @param path Path to an object
    # @param type Type of object (item, am, role)
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def reverse_rbac_with_http_info(path, type, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.reverse_rbac ...'
      end
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling DefaultApi.reverse_rbac"
      end
      # verify the required parameter 'type' is set
      if @api_client.config.client_side_validation && type.nil?
        fail ArgumentError, "Missing the required parameter 'type' when calling DefaultApi.reverse_rbac"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.reverse_rbac"
      end
      # resource path
      local_var_path = '/reverse-rbac'

      # query parameters
      query_params = {}
      query_params[:'path'] = path
      query_params[:'type'] = type
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#reverse_rbac\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Set a rule to a role
    # Set a rule to a role Options:   role-name -    The role name to be updated   path -    The path the rule refers to   capability -    List of the approved/denied capabilities in the path options- [read, create, update, delete, list, deny]   token -    Access token
    # @param role_name The role name to be updated
    # @param path The path the rule refers to
    # @param capability List of the approved/denied capabilities in the path options- [read, create, update, delete, list, deny]
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def set_role_rule(role_name, path, capability, token, opts = {})
      data, _status_code, _headers = set_role_rule_with_http_info(role_name, path, capability, token, opts)
      data
    end

    # Set a rule to a role
    # Set a rule to a role Options:   role-name -    The role name to be updated   path -    The path the rule refers to   capability -    List of the approved/denied capabilities in the path options- [read, create, update, delete, list, deny]   token -    Access token
    # @param role_name The role name to be updated
    # @param path The path the rule refers to
    # @param capability List of the approved/denied capabilities in the path options- [read, create, update, delete, list, deny]
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def set_role_rule_with_http_info(role_name, path, capability, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.set_role_rule ...'
      end
      # verify the required parameter 'role_name' is set
      if @api_client.config.client_side_validation && role_name.nil?
        fail ArgumentError, "Missing the required parameter 'role_name' when calling DefaultApi.set_role_rule"
      end
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling DefaultApi.set_role_rule"
      end
      # verify the required parameter 'capability' is set
      if @api_client.config.client_side_validation && capability.nil?
        fail ArgumentError, "Missing the required parameter 'capability' when calling DefaultApi.set_role_rule"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.set_role_rule"
      end
      # resource path
      local_var_path = '/set-role-rule'

      # query parameters
      query_params = {}
      query_params[:'role-name'] = role_name
      query_params[:'path'] = path
      query_params[:'capability'] = capability
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#set_role_rule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5
    # Calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5 Options:   key-name -    The name of the RSA key to use in the signing process   message -    The message to be signed   token -    Access token
    # @param key_name The name of the RSA key to use in the signing process
    # @param message The message to be signed
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def sign_pkcs1(key_name, message, token, opts = {})
      data, _status_code, _headers = sign_pkcs1_with_http_info(key_name, message, token, opts)
      data
    end

    # Calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5
    # Calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5 Options:   key-name -    The name of the RSA key to use in the signing process   message -    The message to be signed   token -    Access token
    # @param key_name The name of the RSA key to use in the signing process
    # @param message The message to be signed
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def sign_pkcs1_with_http_info(key_name, message, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.sign_pkcs1 ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.sign_pkcs1"
      end
      # verify the required parameter 'message' is set
      if @api_client.config.client_side_validation && message.nil?
        fail ArgumentError, "Missing the required parameter 'message' when calling DefaultApi.sign_pkcs1"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.sign_pkcs1"
      end
      # resource path
      local_var_path = '/sign-pkcs1'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'message'] = message
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#sign_pkcs1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Remove Configuration of client profile.
    # Remove Configuration of client profile. Options:   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def unconfigure(token, opts = {})
      data, _status_code, _headers = unconfigure_with_http_info(token, opts)
      data
    end

    # Remove Configuration of client profile.
    # Remove Configuration of client profile. Options:   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def unconfigure_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.unconfigure ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.unconfigure"
      end
      # resource path
      local_var_path = '/unconfigure'

      # query parameters
      query_params = {}
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#unconfigure\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update a new AKEYLESS CLI version
    # Update a new AKEYLESS CLI version Options:   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def update(token, opts = {})
      data, _status_code, _headers = update_with_http_info(token, opts)
      data
    end

    # Update a new AKEYLESS CLI version
    # Update a new AKEYLESS CLI version Options:   token -    Access token
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def update_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.update"
      end
      # resource path
      local_var_path = '/update'

      # query parameters
      query_params = {}
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update item name and metadata
    # Update item name and metadata Options:   name -    Current item name   new-name -    New item name   new-metadata -    New item metadata   add-tag -    List of the new tags that will be attached to this item. To specify multiple tags use argument multiple times- --add-tag Tag1 --add-tag Tag2   rm-tag -    List of the existent tags that will be removed from this item. To specify multiple tags use argument multiple times- --rm-tag Tag1 --rm-tag Tag2   token -    Access token
    # @param name Current item name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :new_name New item name
    # @option opts [String] :new_metadata New item metadata
    # @option opts [String] :add_tag List of the new tags that will be attached to this item. To specify multiple tags use argument multiple times- --add-tag Tag1 --add-tag Tag2
    # @option opts [String] :rm_tag List of the existent tags that will be removed from this item. To specify multiple tags use argument multiple times- --rm-tag Tag1 --rm-tag Tag2
    # @return [ReplyObj]
    def update_item(name, token, opts = {})
      data, _status_code, _headers = update_item_with_http_info(name, token, opts)
      data
    end

    # Update item name and metadata
    # Update item name and metadata Options:   name -    Current item name   new-name -    New item name   new-metadata -    New item metadata   add-tag -    List of the new tags that will be attached to this item. To specify multiple tags use argument multiple times- --add-tag Tag1 --add-tag Tag2   rm-tag -    List of the existent tags that will be removed from this item. To specify multiple tags use argument multiple times- --rm-tag Tag1 --rm-tag Tag2   token -    Access token
    # @param name Current item name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :new_name New item name
    # @option opts [String] :new_metadata New item metadata
    # @option opts [String] :add_tag List of the new tags that will be attached to this item. To specify multiple tags use argument multiple times- --add-tag Tag1 --add-tag Tag2
    # @option opts [String] :rm_tag List of the existent tags that will be removed from this item. To specify multiple tags use argument multiple times- --rm-tag Tag1 --rm-tag Tag2
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def update_item_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_item ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.update_item"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.update_item"
      end
      # resource path
      local_var_path = '/update-item'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token
      query_params[:'new-name'] = opts[:'new_name'] if !opts[:'new_name'].nil?
      query_params[:'new-metadata'] = opts[:'new_metadata'] if !opts[:'new_metadata'].nil?
      query_params[:'add-tag'] = opts[:'add_tag'] if !opts[:'add_tag'].nil?
      query_params[:'rm-tag'] = opts[:'rm_tag'] if !opts[:'rm_tag'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update role details
    # Update role details Options:   name -    Role name   new-name -    New Role name   new-comment -    New comment about the role   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :new_name New Role name
    # @option opts [String] :new_comment New comment about the role
    # @return [ReplyObj]
    def update_role(name, token, opts = {})
      data, _status_code, _headers = update_role_with_http_info(name, token, opts)
      data
    end

    # Update role details
    # Update role details Options:   name -    Role name   new-name -    New Role name   new-comment -    New comment about the role   token -    Access token
    # @param name Role name
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :new_name New Role name
    # @option opts [String] :new_comment New comment about the role
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def update_role_with_http_info(name, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_role ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.update_role"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.update_role"
      end
      # resource path
      local_var_path = '/update-role'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'token'] = token
      query_params[:'new-name'] = opts[:'new_name'] if !opts[:'new_name'].nil?
      query_params[:'new-comment'] = opts[:'new_comment'] if !opts[:'new_comment'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_role\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update static secret value
    # Update static secret value Options:   name -    Secret name   value -    The new secret value   key -    The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)   multiline -    The provided value is a multiline value (separated by '\\n')   token -    Access token
    # @param name Secret name
    # @param value The new secret value
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :key The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)
    # @option opts [BOOLEAN] :multiline The provided value is a multiline value (separated by &#39;\\n&#39;)
    # @return [ReplyObj]
    def update_secret_val(name, value, token, opts = {})
      data, _status_code, _headers = update_secret_val_with_http_info(name, value, token, opts)
      data
    end

    # Update static secret value
    # Update static secret value Options:   name -    Secret name   value -    The new secret value   key -    The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)   multiline -    The provided value is a multiline value (separated by &#39;\\n&#39;)   token -    Access token
    # @param name Secret name
    # @param value The new secret value
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :key The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)
    # @option opts [BOOLEAN] :multiline The provided value is a multiline value (separated by &#39;\\n&#39;)
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def update_secret_val_with_http_info(name, value, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_secret_val ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.update_secret_val"
      end
      # verify the required parameter 'value' is set
      if @api_client.config.client_side_validation && value.nil?
        fail ArgumentError, "Missing the required parameter 'value' when calling DefaultApi.update_secret_val"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.update_secret_val"
      end
      # resource path
      local_var_path = '/update-secret-val'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'value'] = value
      query_params[:'token'] = token
      query_params[:'key'] = opts[:'key'] if !opts[:'key'].nil?
      query_params[:'multiline'] = opts[:'multiline'] if !opts[:'multiline'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_secret_val\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Upload a PKCS#12 key and certificates
    # Upload a PKCS#12 key and certificates Options:   name -    Name of key to be created   in -    PKCS#12 input file (private key and certificate only)   passphrase -    Passphrase to unlock the pkcs#12 bundle   metadata -    A metadata about the key   tag -    List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   split-level -    The number of fragments that the item will be split into   customer-frg-id -    The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)   cert -    Path to a file that contain the certificate in a PEM format. If this parameter is not empty, the certificate will be taken from here and not from the PKCS#12 input file   token -    Access token
    # @param name Name of key to be created
    # @param _in PKCS#12 input file (private key and certificate only)
    # @param passphrase Passphrase to unlock the pkcs#12 bundle
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata A metadata about the key
    # @option opts [String] :tag List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :split_level The number of fragments that the item will be split into
    # @option opts [String] :customer_frg_id The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)
    # @option opts [String] :cert Path to a file that contain the certificate in a PEM format. If this parameter is not empty, the certificate will be taken from here and not from the PKCS#12 input file
    # @return [ReplyObj]
    def upload_pkcs12(name, _in, passphrase, token, opts = {})
      data, _status_code, _headers = upload_pkcs12_with_http_info(name, _in, passphrase, token, opts)
      data
    end

    # Upload a PKCS#12 key and certificates
    # Upload a PKCS#12 key and certificates Options:   name -    Name of key to be created   in -    PKCS#12 input file (private key and certificate only)   passphrase -    Passphrase to unlock the pkcs#12 bundle   metadata -    A metadata about the key   tag -    List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   split-level -    The number of fragments that the item will be split into   customer-frg-id -    The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)   cert -    Path to a file that contain the certificate in a PEM format. If this parameter is not empty, the certificate will be taken from here and not from the PKCS#12 input file   token -    Access token
    # @param name Name of key to be created
    # @param _in PKCS#12 input file (private key and certificate only)
    # @param passphrase Passphrase to unlock the pkcs#12 bundle
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metadata A metadata about the key
    # @option opts [String] :tag List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :split_level The number of fragments that the item will be split into
    # @option opts [String] :customer_frg_id The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)
    # @option opts [String] :cert Path to a file that contain the certificate in a PEM format. If this parameter is not empty, the certificate will be taken from here and not from the PKCS#12 input file
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def upload_pkcs12_with_http_info(name, _in, passphrase, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.upload_pkcs12 ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.upload_pkcs12"
      end
      # verify the required parameter '_in' is set
      if @api_client.config.client_side_validation && _in.nil?
        fail ArgumentError, "Missing the required parameter '_in' when calling DefaultApi.upload_pkcs12"
      end
      # verify the required parameter 'passphrase' is set
      if @api_client.config.client_side_validation && passphrase.nil?
        fail ArgumentError, "Missing the required parameter 'passphrase' when calling DefaultApi.upload_pkcs12"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.upload_pkcs12"
      end
      # resource path
      local_var_path = '/upload-pkcs12'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'in'] = _in
      query_params[:'passphrase'] = passphrase
      query_params[:'token'] = token
      query_params[:'metadata'] = opts[:'metadata'] if !opts[:'metadata'].nil?
      query_params[:'tag'] = opts[:'tag'] if !opts[:'tag'].nil?
      query_params[:'split-level'] = opts[:'split_level'] if !opts[:'split_level'].nil?
      query_params[:'customer-frg-id'] = opts[:'customer_frg_id'] if !opts[:'customer_frg_id'].nil?
      query_params[:'cert'] = opts[:'cert'] if !opts[:'cert'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#upload_pkcs12\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Upload RSA key
    # Upload RSA key Options:   name -    Name of key to be created   alg -    Key type. options- [RSA1024, RSA2048]   rsa-key-file-path -    RSA private key file path   cert -    Path to a file that contain the certificate in a PEM format.   metadata -    A metadata about the key   tag -    List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   split-level -    The number of fragments that the item will be split into   customer-frg-id -    The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)   token -    Access token
    # @param name Name of key to be created
    # @param alg Key type. options- [RSA1024, RSA2048]
    # @param rsa_key_file_path RSA private key file path
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cert Path to a file that contain the certificate in a PEM format.
    # @option opts [String] :metadata A metadata about the key
    # @option opts [String] :tag List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :split_level The number of fragments that the item will be split into
    # @option opts [String] :customer_frg_id The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)
    # @return [ReplyObj]
    def upload_rsa(name, alg, rsa_key_file_path, token, opts = {})
      data, _status_code, _headers = upload_rsa_with_http_info(name, alg, rsa_key_file_path, token, opts)
      data
    end

    # Upload RSA key
    # Upload RSA key Options:   name -    Name of key to be created   alg -    Key type. options- [RSA1024, RSA2048]   rsa-key-file-path -    RSA private key file path   cert -    Path to a file that contain the certificate in a PEM format.   metadata -    A metadata about the key   tag -    List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2   split-level -    The number of fragments that the item will be split into   customer-frg-id -    The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)   token -    Access token
    # @param name Name of key to be created
    # @param alg Key type. options- [RSA1024, RSA2048]
    # @param rsa_key_file_path RSA private key file path
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cert Path to a file that contain the certificate in a PEM format.
    # @option opts [String] :metadata A metadata about the key
    # @option opts [String] :tag List of the tags attached to this key. To specify multiple tags use argument multiple times- -t Tag1 -t Tag2
    # @option opts [String] :split_level The number of fragments that the item will be split into
    # @option opts [String] :customer_frg_id The customer fragment ID that will be used to split the key (if empty, the key will be created independently of a customer fragment)
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def upload_rsa_with_http_info(name, alg, rsa_key_file_path, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.upload_rsa ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.upload_rsa"
      end
      # verify the required parameter 'alg' is set
      if @api_client.config.client_side_validation && alg.nil?
        fail ArgumentError, "Missing the required parameter 'alg' when calling DefaultApi.upload_rsa"
      end
      # verify the required parameter 'rsa_key_file_path' is set
      if @api_client.config.client_side_validation && rsa_key_file_path.nil?
        fail ArgumentError, "Missing the required parameter 'rsa_key_file_path' when calling DefaultApi.upload_rsa"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.upload_rsa"
      end
      # resource path
      local_var_path = '/upload-rsa'

      # query parameters
      query_params = {}
      query_params[:'name'] = name
      query_params[:'alg'] = alg
      query_params[:'rsa-key-file-path'] = rsa_key_file_path
      query_params[:'token'] = token
      query_params[:'cert'] = opts[:'cert'] if !opts[:'cert'].nil?
      query_params[:'metadata'] = opts[:'metadata'] if !opts[:'metadata'].nil?
      query_params[:'tag'] = opts[:'tag'] if !opts[:'tag'].nil?
      query_params[:'split-level'] = opts[:'split_level'] if !opts[:'split_level'].nil?
      query_params[:'customer-frg-id'] = opts[:'customer_frg_id'] if !opts[:'customer_frg_id'].nil?

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#upload_rsa\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Verifies an RSA PKCS#1 v1.5 signature
    # Verifies an RSA PKCS#1 v1.5 signature Options:   key-name -    The name of the RSA key to use in the verification process   message -    The message to be verified   signature -    The message's signature   token -    Access token
    # @param key_name The name of the RSA key to use in the verification process
    # @param message The message to be verified
    # @param signature The message&#39;s signature
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [ReplyObj]
    def verify_pkcs1(key_name, message, signature, token, opts = {})
      data, _status_code, _headers = verify_pkcs1_with_http_info(key_name, message, signature, token, opts)
      data
    end

    # Verifies an RSA PKCS#1 v1.5 signature
    # Verifies an RSA PKCS#1 v1.5 signature Options:   key-name -    The name of the RSA key to use in the verification process   message -    The message to be verified   signature -    The message&#39;s signature   token -    Access token
    # @param key_name The name of the RSA key to use in the verification process
    # @param message The message to be verified
    # @param signature The message&#39;s signature
    # @param token Access token
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplyObj, Fixnum, Hash)>] ReplyObj data, response status code and response headers
    def verify_pkcs1_with_http_info(key_name, message, signature, token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.verify_pkcs1 ...'
      end
      # verify the required parameter 'key_name' is set
      if @api_client.config.client_side_validation && key_name.nil?
        fail ArgumentError, "Missing the required parameter 'key_name' when calling DefaultApi.verify_pkcs1"
      end
      # verify the required parameter 'message' is set
      if @api_client.config.client_side_validation && message.nil?
        fail ArgumentError, "Missing the required parameter 'message' when calling DefaultApi.verify_pkcs1"
      end
      # verify the required parameter 'signature' is set
      if @api_client.config.client_side_validation && signature.nil?
        fail ArgumentError, "Missing the required parameter 'signature' when calling DefaultApi.verify_pkcs1"
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling DefaultApi.verify_pkcs1"
      end
      # resource path
      local_var_path = '/verify-pkcs1'

      # query parameters
      query_params = {}
      query_params[:'key-name'] = key_name
      query_params[:'message'] = message
      query_params[:'signature'] = signature
      query_params[:'token'] = token

      # header parameters
      header_params = {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = {}

      # http body (model)
      post_body = nil
      auth_names = []
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => 'ReplyObj')
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#verify_pkcs1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
